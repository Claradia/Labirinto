<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Labirinto Geométrico</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --cor-fundo: #121212;
            --cor-surface: #1e1e1e;
            --cor-primaria: #bb86fc;
            --cor-secundaria: #03dac6;
            --cor-texto: #e1e1e1;
            --tamanho-bloco: 12vw;
            --tamanho-bloco-max: 60px;
            --tamanho-bloco-min: 40px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--cor-fundo);
            color: var(--cor-texto);
            text-align: center;
            margin: 0;
            padding: 10px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        h1 {
            font-size: 1.5rem;
            margin: 10px 0;
        }

        .info-nivel, .info-pontuacao {
            font-size: 1rem;
            margin: 5px 0;
        }

        .labirinto-container {
            display: flex;
            justify-content: center;
            margin: 10px 0;
            padding: 5px;
            overflow: auto;
            max-width: 100%;
        }

        .labirinto {
            display: grid;
            gap: 2px;
            margin: 0 auto;
            background-color: var(--cor-surface);
            padding: 3px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .bloco {
            width: clamp(var(--tamanho-bloco-min), var(--tamanho-bloco), var(--tamanho-bloco-max));
            height: clamp(var(--tamanho-bloco-min), var(--tamanho-bloco), var(--tamanho-bloco-max));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            transition: all 0.2s;
            cursor: pointer;
            border-radius: 4px;
        }

        .caminho {
            background-color: rgba(30, 30, 46, 0.5);
            border: 1px solid var(--cor-primaria);
        }

        .caminho-dificil {
            background-color: rgba(30, 30, 70, 0.7);
            border: 2px solid var(--cor-primaria);
        }

        .parede {
            background-color: rgba(70, 70, 70, 0.8);
            border: 1px solid #444;
            cursor: not-allowed;
        }

        .personagem {
            background-color: var(--cor-secundaria);
            width: 70%;
            height: 70%;
            border-radius: 50%;
            box-shadow: 0 0 0 2px var(--cor-surface), 0 0 0 4px var(--cor-secundaria);
            transition: transform 0.2s;
        }

        .saida {
            background-color: var(--cor-primaria);
            animation: pulse 2s infinite ease-in-out;
        }

        .mensagem {
            margin: 10px 0;
            font-size: 0.9rem;
            min-height: 20px;
            padding: 5px;
        }

        .mensagem.acerto {
            color: #4caf50;
        }

        .mensagem.erro {
            color: #f44336;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .modal-content {
            background-color: var(--cor-surface);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }

        .fechar-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--cor-texto);
            cursor: pointer;
        }

        .pergunta {
            font-size: 1.1rem;
            margin-bottom: 15px;
            text-align: left;
        }

        .opcoes-resposta {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .opcao {
            padding: 12px;
            background-color: rgba(30, 30, 46, 0.7);
            border: 1px solid var(--cor-primaria);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 0.9rem;
            text-align: center;
        }

        .opcao:hover, .opcao:focus {
            background-color: rgba(30, 30, 70, 0.9);
        }

        .tela-inicio, .tela-fim {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
        }

        .tela-conteudo {
            background-color: var(--cor-surface);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .botao-iniciar {
            padding: 12px 24px;
            background-color: var(--cor-primaria);
            color: #000;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
            transition: transform 0.2s, background-color 0.2s;
        }

        .botao-iniciar:active {
            transform: scale(0.98);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .controles-mobile {
            display: none;
            grid-template-areas:
                ". cima ."
                "esquerda baixo direita";
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .controle {
            background-color: rgba(30, 30, 46, 0.7);
            border: 1px solid var(--cor-primaria);
            border-radius: 8px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
        }

        .controle:active {
            background-color: var(--cor-primaria);
            color: #000;
        }

        .controle-cima { grid-area: cima; }
        .controle-baixo { grid-area: baixo; }
        .controle-esquerda { grid-area: esquerda; }
        .controle-direita { grid-area: direita; }

        @media (max-width: 768px) {
            :root {
                --tamanho-bloco: 15vw;
            }

            .controles-mobile {
                display: grid;
            }

            .labirinto {
                margin-bottom: 20px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --tamanho-bloco: 18vw;
                --tamanho-bloco-min: 30px;
            }

            h1 {
                font-size: 1.3rem;
            }

            .modal-content {
                padding: 15px;
            }

            .pergunta {
                font-size: 1rem;
            }

            .opcao {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>Labirinto Geométrico</h1>
    <div class="info-nivel">Nível: <span id="nivel-atual">1</span></div>
    <div class="info-pontuacao">Acertos: <span id="acertos">0</span> | Erros: <span id="erros">0</span></div>

    <div class="labirinto-container">
        <div id="labirinto" class="labirinto"></div>
    </div>

    <div id="mensagem" class="mensagem"></div>

    <div class="controles-mobile">
        <div class="controle controle-cima" id="controle-cima">↑</div>
        <div class="controle controle-baixo" id="controle-baixo">↓</div>
        <div class="controle controle-esquerda" id="controle-esquerda">←</div>
        <div class="controle controle-direita" id="controle-direita">→</div>
    </div>

    <div id="modal-pergunta" class="modal">
        <div class="modal-content">
            <button class="fechar-modal">&times;</button>
            <div id="texto-pergunta" class="pergunta"></div>
            <div id="opcoes-resposta" class="opcoes-resposta"></div>
        </div>
    </div>

    <div id="tela-inicio" class="tela-inicio">
        <div class="tela-conteudo">
            <h2>Labirinto Geométrico</h2>
            <p>Responda perguntas de geometria para navegar pelo labirinto!</p>
            <p>Use os controles ou clique nos blocos adjacentes para se mover.</p>
            <button id="botao-iniciar" class="botao-iniciar">Iniciar Jogo</button>
        </div>
    </div>

    <div id="tela-fim" class="tela-fim" style="display: none;">
        <div class="tela-conteudo">
            <h2>Parabéns!</h2>
            <p id="mensagem-final"></p>
            <button id="botao-reiniciar" class="botao-iniciar">Jogar Novamente</button>
        </div>
    </div>

    <script>
        // Elementos do DOM
        const elementos = {
            labirinto: document.getElementById('labirinto'),
            mensagem: document.getElementById('mensagem'),
            nivelAtual: document.getElementById('nivel-atual'),
            acertos: document.getElementById('acertos'),
            erros: document.getElementById('erros'),
            modalPergunta: document.getElementById('modal-pergunta'),
            textoPergunta: document.getElementById('texto-pergunta'),
            opcoesResposta: document.getElementById('opcoes-resposta'),
            telaInicio: document.getElementById('tela-inicio'),
            telaFim: document.getElementById('tela-fim'),
            botaoIniciar: document.getElementById('botao-iniciar'),
            botaoReiniciar: document.getElementById('botao-reiniciar'),
            mensagemFinal: document.getElementById('mensagem-final'),
            fecharModal: document.querySelector('.fechar-modal'),
            controles: {
                cima: document.getElementById('controle-cima'),
                baixo: document.getElementById('controle-baixo'),
                esquerda: document.getElementById('controle-esquerda'),
                direita: document.getElementById('controle-direita')
            }
        };

        // Configurações do jogo
        const config = {
            nivelInicial: 1,
            tamanhoInicial: 5,
            incrementoTamanho: 1,
            maxNiveis: 5,
            maxTentativasCaminho: 10,
            probabilidadeParede: 0.4,
            chancePerguntaDificil: 0.3,
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        };

        // Banco de perguntas
        const perguntas = {
            faceis: [
                {
                    pergunta: "Quantas faces tem um cubo?",
                    opcoes: ["4", "6", "8", "12"],
                    resposta: 1
                },
                {
                    pergunta: "Qual forma geométrica lembra uma lata de refrigerante?",
                    opcoes: ["Esfera", "Cubo", "Cilindro", "Pirâmide"],
                    resposta: 2
                },
                {
                    pergunta: "Quantos vértices tem uma pirâmide de base quadrada?",
                    opcoes: ["4", "5", "6", "8"],
                    resposta: 1
                }
            ],
            medias: [
                {
                    pergunta: "Qual poliedro é formado apenas por faces triangulares?",
                    opcoes: ["Cubo", "Octaedro", "Cilindro", "Dodecaedro"],
                    resposta: 1
                },
                {
                    pergunta: "Quantas diagonais tem um paralelepípedo?",
                    opcoes: ["4", "6", "8", "12"],
                    resposta: 0
                }
            ],
            dificeis: [
                {
                    pergunta: "Qual poliedro regular tem 20 faces triangulares?",
                    opcoes: ["Dodecaedro", "Icosaedro", "Tetraedro", "Octaedro"],
                    resposta: 1
                },
                {
                    pergunta: "Quantas arestas tem um dodecaedro regular?",
                    opcoes: ["12", "20", "30", "60"],
                    resposta: 2
                }
            ]
        };

        // Estado do jogo
        const estado = {
            nivel: config.nivelInicial,
            tamanhoMapa: config.tamanhoInicial,
            personagemPos: { x: 0, y: 0 },
            saidaPos: { x: 0, y: 0 },
            jogoAtivo: false,
            labirinto: [],
            caminhoValido: [],
            caminhosAlternativos: [],
            destinoClicado: null,
            acertos: 0,
            erros: 0,
            perguntaAtual: null,
            isPerguntaDificil: false
        };

        // Funções do jogo
        function gerarLabirinto() {
            const tamanho = estado.tamanhoMapa;
            estado.labirinto = [];
            
            for (let y = 0; y < tamanho; y++) {
                estado.labirinto[y] = [];
                for (let x = 0; x < tamanho; x++) {
                    estado.labirinto[y][x] = Math.random() > config.probabilidadeParede ? ' ' : 'P';
                }
            }
            
            estado.personagemPos = { x: 0, y: 0 };
            estado.labirinto[0][0] = ' ';
            
            estado.saidaPos = { x: tamanho-1, y: tamanho-1 };
            estado.labirinto[tamanho-1][tamanho-1] = 'S';
        }

        function encontrarCaminhoValido() {
            const tamanho = estado.tamanhoMapa;
            const visitados = Array(tamanho).fill().map(() => Array(tamanho).fill(false));
            const fila = [{x: 0, y: 0, path: [{x: 0, y: 0}]}];
            visitados[0][0] = true;
            
            const direcoes = [
                {dx: 0, dy: -1}, {dx: 1, dy: 0}, 
                {dx: 0, dy: 1}, {dx: -1, dy: 0}
            ];
            
            while (fila.length > 0) {
                const atual = fila.shift();
                
                if (atual.x === estado.saidaPos.x && atual.y === estado.saidaPos.y) {
                    estado.caminhoValido = atual.path;
                    return true;
                }
                
                for (const dir of direcoes) {
                    const nx = atual.x + dir.dx;
                    const ny = atual.y + dir.dy;
                    
                    if (nx >= 0 && nx < tamanho && ny >= 0 && ny < tamanho && 
                        (estado.labirinto[ny][nx] === ' ' || estado.labirinto[ny][nx] === 'S') && 
                        !visitados[ny][nx]) {
                        visitados[ny][nx] = true;
                        fila.push({
                            x: nx,
                            y: ny,
                            path: [...atual.path, {x: nx, y: ny}]
                        });
                    }
                }
            }
            
            return false;
        }

        function gerarLabirintoValido() {
            let tentativas = 0;
            do {
                gerarLabirinto();
                tentativas++;
            } while (!encontrarCaminhoValido() && tentativas < config.maxTentativasCaminho);
            
            if (tentativas >= config.maxTentativasCaminho) {
                criarLabirintoPadrao();
                encontrarCaminhoValido();
            }
            
            encontrarCaminhosAlternativos();
        }

        function criarLabirintoPadrao() {
            const tamanho = estado.tamanhoMapa;
            estado.labirinto = [];
            
            for (let y = 0; y < tamanho; y++) {
                estado.labirinto[y] = [];
                for (let x = 0; x < tamanho; x++) {
                    if (x === y || x === y+1 || x === y-1 || 
                        (x > 0 && x < tamanho-1 && y > 0 && y < tamanho-1 && Math.random() > 0.3)) {
                        estado.labirinto[y][x] = ' ';
                    } else {
                        estado.labirinto[y][x] = 'P';
                    }
                }
            }
            
            estado.personagemPos = { x: 0, y: 0 };
            estado.labirinto[0][0] = ' ';
            
            estado.saidaPos = { x: tamanho-1, y: tamanho-1 };
            estado.labirinto[tamanho-1][tamanho-1] = 'S';
        }

        function encontrarCaminhosAlternativos() {
            const tamanho = estado.tamanhoMapa;
            const visitados = Array(tamanho).fill().map(() => Array(tamanho).fill(false));
            estado.caminhosAlternativos = [];
            
            estado.caminhoValido.forEach(pos => {
                visitados[pos.y][pos.x] = true;
            });
            
            for (let y = 0; y < tamanho; y++) {
                for (let x = 0; x < tamanho; x++) {
                    if (estado.labirinto[y][x] === ' ' && !visitados[y][x]) {
                        const caminho = [];
                        preencherCaminho(x, y, visitados, caminho);
                        if (caminho.length > 0) {
                            estado.caminhosAlternativos.push(caminho);
                        }
                    }
                }
            }
        }

        function preencherCaminho(x, y, visitados, caminho) {
            const tamanho = estado.tamanhoMapa;
            if (x < 0 || x >= tamanho || y < 0 || y >= tamanho || 
                visitados[y][x] || estado.labirinto[y][x] === 'P') {
                return;
            }
            
            visitados[y][x] = true;
            caminho.push({x, y});
            
            preencherCaminho(x+1, y, visitados, caminho);
            preencherCaminho(x-1, y, visitados, caminho);
            preencherCaminho(x, y+1, visitados, caminho);
            preencherCaminho(x, y-1, visitados, caminho);
        }

        function atualizarUI() {
            if (!elementos.labirinto) return;
            
            elementos.labirinto.innerHTML = '';
            elementos.labirinto.style.gridTemplateColumns = `repeat(${estado.tamanhoMapa}, 1fr)`;
            
            for (let y = 0; y < estado.tamanhoMapa; y++) {
                for (let x = 0; x < estado.tamanhoMapa; x++) {
                    const bloco = document.createElement('div');
                    bloco.classList.add('bloco');
                    
                    const noCaminhoPrincipal = estado.caminhoValido.some(pos => pos.x === x && pos.y === y);
                    const noCaminhoAlternativo = estado.caminhosAlternativos.some(caminho => 
                        caminho.some(pos => pos.x === x && pos.y === y));
                    
                    if (estado.labirinto[y][x] === 'P') {
                        bloco.classList.add('parede');
                    } else if (estado.labirinto[y][x] === 'S') {
                        bloco.classList.add('saida');
                    } else if (noCaminhoPrincipal || noCaminhoAlternativo) {
                        const isDificil = noCaminhoAlternativo && 
                                         Math.random() < config.chancePerguntaDificil &&
                                         !(x === estado.saidaPos.x && y === estado.saidaPos.y);
                        
                        if (isDificil) {
                            bloco.classList.add('caminho-dificil');
                            bloco.setAttribute('data-dificil', 'true');
                        } else {
                            bloco.classList.add('caminho');
                        }
                    } else {
                        bloco.classList.add('parede');
                    }
                    
                    if (x === estado.personagemPos.x && y === estado.personagemPos.y) {
                        const personagem = document.createElement('div');
                        personagem.classList.add('personagem');
                        bloco.appendChild(personagem);
                    }
                    
                    if ((noCaminhoPrincipal || noCaminhoAlternativo) && 
                        !(x === estado.personagemPos.x && y === estado.personagemPos.y)) {
                        bloco.addEventListener('click', () => clicarNoBloco(x, y));
                    }
                    
                    elementos.labirinto.appendChild(bloco);
                }
            }
            
            if (elementos.nivelAtual) {
                elementos.nivelAtual.textContent = estado.nivel;
            }
            if (elementos.acertos) {
                elementos.acertos.textContent = estado.acertos;
            }
            if (elementos.erros) {
                elementos.erros.textContent = estado.erros;
            }
        }

        function mostrarMensagem(texto, tipo) {
            if (!elementos.mensagem) return;
            
            elementos.mensagem.textContent = texto;
            elementos.mensagem.className = `mensagem ${tipo}`;
            setTimeout(() => {
                elementos.mensagem.textContent = '';
            }, 2000);
        }

        function clicarNoBloco(x, y) {
            if (!estado.jogoAtivo) return;
            
            const dx = Math.abs(estado.personagemPos.x - x);
            const dy = Math.abs(estado.personagemPos.y - y);
            
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                estado.destinoClicado = {x, y};
                
                const bloco = document.querySelector(`.bloco[style="grid-column-start: ${x+1}; grid-row-start: ${y+1};"]`);
                estado.isPerguntaDificil = bloco && bloco.hasAttribute('data-dificil');
                
                mostrarPergunta();
            } else {
                mostrarMensagem("Mova apenas para blocos adjacentes!", 'erro');
            }
        }

        function mostrarPergunta() {
            let perguntaAleatoria;
            const nivel = estado.nivel;
            
            if (estado.isPerguntaDificil) {
                const perguntasDisponiveis = perguntas.dificeis;
                perguntaAleatoria = perguntasDisponiveis[Math.floor(Math.random() * perguntasDisponiveis.length)];
                mostrarMensagem("Pergunta difícil!", 'erro');
            } else if (nivel <= 2) {
                const perguntasDisponiveis = perguntas.faceis;
                perguntaAleatoria = perguntasDisponiveis[Math.floor(Math.random() * perguntasDisponiveis.length)];
            } else if (nivel <= 4) {
                const rand = Math.random();
                const perguntasDisponiveis = rand < 0.7 ? perguntas.faceis : perguntas.medias;
                perguntaAleatoria = perguntasDisponiveis[Math.floor(Math.random() * perguntasDisponiveis.length)];
            } else {
                const rand = Math.random();
                const perguntasDisponiveis = rand < 0.5 ? perguntas.medias : perguntas.dificeis;
                perguntaAleatoria = perguntasDisponiveis[Math.floor(Math.random() * perguntasDisponiveis.length)];
            }
            
            estado.perguntaAtual = perguntaAleatoria;
            
            if (elementos.textoPergunta) {
                elementos.textoPergunta.textContent = perguntaAleatoria.pergunta;
            }
            
            if (elementos.opcoesResposta) {
                elementos.opcoesResposta.innerHTML = '';
                
                perguntaAleatoria.opcoes.forEach((opcao, index) => {
                    const botao = document.createElement('button');
                    botao.classList.add('opcao');
                    botao.textContent = opcao;
                    botao.addEventListener('click', () => verificarResposta(index === perguntaAleatoria.resposta));
                    elementos.opcoesResposta.appendChild(botao);
                });
            }
            
            if (elementos.modalPergunta) {
                elementos.modalPergunta.style.display = 'flex';
            }
        }

        function verificarResposta(correta) {
            if (elementos.modalPergunta) {
                elementos.modalPergunta.style.display = 'none';
            }
            
            if (correta) {
                estado.acertos++;
                mostrarMensagem("Correto! Avançando...", 'acerto');
                moverPersonagemParaDestino();
            } else {
                estado.erros++;
                mostrarMensagem("Incorreto! Tente novamente.", 'erro');
            }
            
            atualizarUI();
        }

        function moverPersonagemParaDestino() {
            estado.personagemPos = {...estado.destinoClicado};
            atualizarUI();
            
            if (estado.personagemPos.x === estado.saidaPos.x && estado.personagemPos.y === estado.saidaPos.y) {
                estado.jogoAtivo = false;
                
                if (estado.nivel >= config.maxNiveis) {
                    finalizarJogo(`Parabéns! Você completou todos os ${config.maxNiveis} níveis!`);
                } else {
                    setTimeout(() => {
                        estado.nivel++;
                        estado.tamanhoMapa += config.incrementoTamanho;
                        estado.jogoAtivo = true;
                        gerarLabirintoValido();
                        atualizarUI();
                    }, 1000);
                }
            }
        }

        function finalizarJogo(mensagem) {
            if (elementos.mensagemFinal) {
                elementos.mensagemFinal.textContent = `${mensagem} Acertos: ${estado.acertos} | Erros: ${estado.erros}`;
            }
            if (elementos.telaFim) {
                elementos.telaFim.style.display = 'flex';
            }
        }

        function moverPersonagem(dx, dy) {
            if (!estado.jogoAtivo) return;
            
            const novoX = estado.personagemPos.x + dx;
            const novoY = estado.personagemPos.y + dy;
            
            const noCaminhoPrincipal = estado.caminhoValido.some(pos => pos.x === novoX && pos.y === novoY);
            const noCaminhoAlternativo = estado.caminhosAlternativos.some(caminho => 
                caminho.some(pos => pos.x === novoX && pos.y === novoY));
            const naSaida = (novoX === estado.saidaPos.x && novoY === estado.saidaPos.y);
            
            if (novoX >= 0 && novoX < estado.tamanhoMapa && 
                novoY >= 0 && novoY < estado.tamanhoMapa && 
                (noCaminhoPrincipal || noCaminhoAlternativo || naSaida)) {
                
                estado.personagemPos.x = novoX;
                estado.personagemPos.y = novoY;
                atualizarUI();
                
                if (naSaida) {
                    estado.jogoAtivo = false;
                    
                    if (estado.nivel >= config.maxNiveis) {
                        finalizarJogo(`Parabéns! Você completou todos os ${config.maxNiveis} níveis!`);
                    } else {
                        setTimeout(() => {
                            estado.nivel++;
                            estado.tamanhoMapa += config.incrementoTamanho;
                            estado.jogoAtivo = true;
                            gerarLabirintoValido();
                            atualizarUI();
                        }, 1000);
                    }
                }
            }
        }

        function iniciarJogo() {
            estado.jogoAtivo = true;
            estado.nivel = config.nivelInicial;
            estado.tamanhoMapa = config.tamanhoInicial;
            estado.acertos = 0;
            estado.erros = 0;
            
            gerarLabirintoValido();
            atualizarUI();
            
            if (elementos.telaInicio) {
                elementos.telaInicio.style.display = 'none';
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            if (elementos.botaoIniciar) {
                elementos.botaoIniciar.addEventListener('click', iniciarJogo);
            }
            
            if (elementos.botaoReiniciar) {
                elementos.botaoReiniciar.addEventListener('click', iniciarJogo);
            }
            
            if (elementos.fecharModal) {
                elementos.fecharModal.addEventListener('click', () => {
                    if (elementos.modalPergunta) {
                        elementos.modalPergunta.style.display = 'none';
                    }
                });
            }
            
            // Controles mobile
            if (config.isMobile) {
                if (elementos.controles.cima) {
                    elementos.controles.cima.addEventListener('click', () => moverPersonagem(0, -1));
                }
                if (elementos.controles.baixo) {
                    elementos.controles.baixo.addEventListener('click', () => moverPersonagem(0, 1));
                }
                if (elementos.controles.esquerda) {
                    elementos.controles.esquerda.addEventListener('click', () => moverPersonagem(-1, 0));
                }
                if (elementos.controles.direita) {
                    elementos.controles.direita.addEventListener('click', () => moverPersonagem(1, 0));
                }
            }
            
            // Teclado
            window.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowUp': moverPersonagem(0, -1); break;
                    case 'ArrowDown': moverPersonagem(0, 1); break;
                    case 'ArrowLeft': moverPersonagem(-1, 0); break;
                    case 'ArrowRight': moverPersonagem(1, 0); break;
                }
            });
        });

        // Inicialização
        if (elementos.telaInicio) {
            elementos.telaInicio.style.display = 'flex';
        }
    </script>
</body>
</html>