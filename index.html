<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Labirinto Geométrico</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ... (mantido o mesmo estilo anterior) ... */
    </style>
</head>
<body>
    <!-- ... (mantido o mesmo HTML anterior) ... -->

    <script>
        // ... (mantido o mesmo código anterior até a função gerarLabirinto) ...

        function gerarLabirinto() {
            const tamanho = estado.tamanhoMapa;
            const nivelIndex = estado.nivel - 1;
            estado.labirinto = [];
            estado.morangosRestantes = 0;
            
            const probParede = config.probabilidadeParede[nivelIndex];
            const probMorango = config.chanceMorango[nivelIndex];
            const probMorangoDificil = config.chanceMorangoDificil[nivelIndex];
            
            // Fase 1: Labirinto simples
            if (estado.nivel === 1) {
                for (let y = 0; y < tamanho; y++) {
                    estado.labirinto[y] = [];
                    for (let x = 0; x < tamanho; x++) {
                        // Garante um caminho principal diagonal
                        if (x === y || x === y+1 || x === y-1) {
                            if (Math.random() < probMorango) {
                                const isDificil = Math.random() < probMorangoDificil;
                                estado.labirinto[y][x] = isDificil ? 'MD' : 'M';
                                estado.morangosRestantes++;
                            } else {
                                estado.labirinto[y][x] = ' ';
                            }
                        } else if (Math.random() < probParede) {
                            estado.labirinto[y][x] = 'P';
                        } else {
                            if (Math.random() < probMorango) {
                                const isDificil = Math.random() < probMorangoDificil;
                                estado.labirinto[y][x] = isDificil ? 'MD' : 'M';
                                estado.morangosRestantes++;
                            } else {
                                estado.labirinto[y][x] = ' ';
                            }
                        }
                    }
                }
            } 
            // Fase 2: Labirinto com mais paredes
            else if (estado.nivel === 2) {
                for (let y = 0; y < tamanho; y++) {
                    estado.labirinto[y] = [];
                    for (let x = 0; x < tamanho; x++) {
                        if (Math.random() < probParede) {
                            estado.labirinto[y][x] = 'P';
                        } else {
                            if (Math.random() < probMorango) {
                                const isDificil = Math.random() < probMorangoDificil;
                                estado.labirinto[y][x] = isDificil ? 'MD' : 'M';
                                estado.morangosRestantes++;
                            } else {
                                estado.labirinto[y][x] = ' ';
                            }
                        }
                    }
                }
            }
            // Fase 3: Labirinto complexo
            else if (estado.nivel === 3) {
                for (let y = 0; y < tamanho; y++) {
                    estado.labirinto[y] = [];
                    for (let x = 0; x < tamanho; x++) {
                        if ((x % 2 === 0 && y % 2 !== 0) || (y % 2 === 0 && x % 2 !== 0)) {
                            if (Math.random() < 0.7) {
                                estado.labirinto[y][x] = 'P';
                            } else {
                                if (Math.random() < probMorango) {
                                    const isDificil = Math.random() < probMorangoDificil;
                                    estado.labirinto[y][x] = isDificil ? 'MD' : 'M';
                                    estado.morangosRestantes++;
                                } else {
                                    estado.labirinto[y][x] = ' ';
                                }
                            }
                        } else {
                            if (Math.random() < probMorango) {
                                const isDificil = Math.random() < probMorangoDificil;
                                estado.labirinto[y][x] = isDificil ? 'MD' : 'M';
                                estado.morangosRestantes++;
                            } else {
                                estado.labirinto[y][x] = ' ';
                            }
                        }
                    }
                }
            }
            
            // Garantir que a posição inicial esteja vazia
            estado.personagemPos = { x: 0, y: 0 };
            estado.labirinto[0][0] = ' ';
            
            // Definir saída em posições estratégicas para cada nível
            let saidaX, saidaY;
            let tentativas = 0;
            const maxTentativas = 100;
            
            do {
                // Estratégias diferentes para cada nível
                if (estado.nivel === 1) {
                    // Nível 1: Saída no canto oposto ou no meio da borda direita/inferior
                    if (Math.random() > 0.7) {
                        // 30% de chance de estar no canto oposto
                        saidaX = tamanho - 1;
                        saidaY = tamanho - 1;
                    } else if (Math.random() > 0.5) {
                        // 35% de chance de estar no meio da borda direita
                        saidaX = tamanho - 1;
                        saidaY = Math.floor(tamanho / 2);
                    } else {
                        // 35% de chance de estar no meio da borda inferior
                        saidaX = Math.floor(tamanho / 2);
                        saidaY = tamanho - 1;
                    }
                } else if (estado.nivel === 2) {
                    // Nível 2: Saída em posições mais centrais ou em cantos estratégicos
                    const estrategia = Math.random();
                    if (estrategia > 0.75) {
                        // 25% de chance - Canto superior direito
                        saidaX = tamanho - 1;
                        saidaY = 0;
                    } else if (estrategia > 0.5) {
                        // 25% de chance - Canto inferior esquerdo
                        saidaX = 0;
                        saidaY = tamanho - 1;
                    } else if (estrategia > 0.25) {
                        // 25% de chance - Centro direito
                        saidaX = tamanho - 1;
                        saidaY = Math.floor(tamanho / 2);
                    } else {
                        // 25% de chance - Centro inferior
                        saidaX = Math.floor(tamanho / 2);
                        saidaY = tamanho - 1;
                    }
                } else {
                    // Nível 3: Saída em posições mais desafiadoras
                    const estrategia = Math.random();
                    if (estrategia > 0.8) {
                        // 20% de chance - Quase centro (ligeiramente deslocado)
                        saidaX = Math.floor(tamanho * 0.6);
                        saidaY = Math.floor(tamanho * 0.6);
                    } else if (estrategia > 0.6) {
                        // 20% de chance - Entre o centro e o canto
                        saidaX = Math.floor(tamanho * 0.75);
                        saidaY = Math.floor(tamanho * 0.25);
                    } else if (estrategia > 0.4) {
                        // 20% de chance - Posição aleatória no quadrante superior direito
                        saidaX = Math.floor(Math.random() * (tamanho/2)) + Math.floor(tamanho/2);
                        saidaY = Math.floor(Math.random() * (tamanho/2));
                    } else if (estrategia > 0.2) {
                        // 20% de chance - Posição aleatória no quadrante inferior esquerdo
                        saidaX = Math.floor(Math.random() * (tamanho/2));
                        saidaY = Math.floor(Math.random() * (tamanho/2)) + Math.floor(tamanho/2);
                    } else {
                        // 20% de chance - Posição completamente aleatória
                        saidaX = Math.floor(Math.random() * tamanho);
                        saidaY = Math.floor(Math.random() * tamanho);
                    }
                }
                
                tentativas++;
                if (tentativas >= maxTentativas) {
                    // Se não encontrar posição válida, coloca no canto oposto
                    saidaX = tamanho - 1;
                    saidaY = tamanho - 1;
                    break;
                }
            } while ((saidaX === 0 && saidaY === 0) || estado.labirinto[saidaY][saidaX] === 'P');
            
            estado.saidaPos = { x: saidaX, y: saidaY };
            estado.labirinto[saidaY][saidaX] = 'S';
        }

        // ... (mantido o resto do código anterior) ...
    </script>
</body>
</html>