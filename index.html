<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Labirinto Geom√©trico</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --cor-fundo: #4a6b3a;
            --cor-surface: #3a5a2a;
            --cor-primaria: #8b4513;
            --cor-secundaria: #f8f8f8;
            --cor-texto: #ffffff;
            --cor-caminho: #f5deb3;
            --cor-caminho-dificil: #e6c9a8;
            --tamanho-bloco: min(12vw, 60px);
            --tamanho-bloco-min: 30px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--cor-fundo);
            color: var(--cor-texto);
            text-align: center;
            margin: 0;
            padding: 10px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        .header {
            margin-bottom: 10px;
            flex-shrink: 0;
            background-color: var(--cor-surface);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: relative;
        }

        h1 {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            margin: 10px 0;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        .info-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin: 5px 0;
            gap: 10px;
        }

        .info-nivel, .info-morangos, .info-tempo {
            font-size: clamp(0.9rem, 3vw, 1rem);
            margin: 5px;
            min-width: 120px;
            background-color: var(--cor-primaria);
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .labirinto-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            padding: 5px;
            overflow: auto;
            width: 100%;
        }

        .labirinto {
            display: grid;
            gap: 2px;
            margin: 0 auto;
            background-color: var(--cor-surface);
            padding: 3px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 80vh;
        }

        .bloco {
            width: var(--tamanho-bloco);
            height: var(--tamanho-bloco);
            min-width: var(--tamanho-bloco-min);
            min-height: var(--tamanho-bloco-min);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            transition: all 0.2s;
            cursor: pointer;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .caminho {
            background-color: var(--cor-caminho);
            border: 1px solid #d2b48c;
        }

        .caminho-dificil {
            background-color: var(--cor-caminho-dificil);
            border: 2px solid #c19a6b;
        }

        .parede {
            background-color: #2a3a1a;
            background-image: url('https://cdn-icons-png.flaticon.com/256/490/490091.png');
            background-size: 70% 70%;
            background-repeat: no-repeat;
            background-position: center;
            border: 1px solid #1b1b1b;
            cursor: not-allowed;
        }

        .morango {
            background-color: var(--cor-caminho);
            border: 1px solid #d2b48c;
        }

        .morango::after {
            content: "üçì";
            position: absolute;
            font-size: 1.5em;
            animation: pulse 1.5s infinite ease-in-out;
        }

        .morango-dificil {
            background-color: var(--cor-caminho-dificil);
            border: 2px solid #c19a6b;
        }

        .morango-dificil::after {
            content: "üçì";
            position: absolute;
            font-size: 1.8em;
            animation: pulse 1.2s infinite ease-in-out;
        }

        .personagem {
            width: 90%;
            height: 90%;
            background-image: url('https://artpoin.com/wp-content/uploads/2023/12/artpoin-safari26.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: transform 0.2s;
        }

        .saida {
            background-color: var(--cor-caminho);
            border: 1px solid #d2b48c;
            position: relative;
        }

        .mensagem {
            margin: 10px 0;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            min-height: 20px;
            padding: 5px;
            flex-shrink: 0;
            background-color: var(--cor-surface);
            border-radius: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .mensagem.acerto {
            color: #a8ffa8;
            text-shadow: 0 0 3px #4caf50;
        }

        .mensagem.erro {
            color: #ffa8a8;
            text-shadow: 0 0 3px #f44336;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(2, 2, 2, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .modal-content {
            background-color: var(--cor-surface);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            margin: 10px;
            border: 2px solid var(--cor-primaria);
        }

        .fechar-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--cor-texto);
            cursor: pointer;
        }

        .pergunta {
            font-size: clamp(1rem, 4vw, 1.1rem);
            margin-bottom: 15px;
            text-align: left;
            color: #fff;
            line-height: 1.4;
        }

        .opcoes-resposta {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .opcao {
            padding: 12px;
            background-color: var(--cor-primaria);
            border: 1px solid var(--cor-primaria);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            text-align: center;
            color: white;
        }

        .opcao:hover, .opcao:focus {
            background-color: #a0522d;
            transform: translateY(-2px);
        }

        .tela-inicio, .tela-fim {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
        }

        .tela-conteudo {
            background-color: var(--cor-surface);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            margin: 10px;
            border: 2px solid var(--cor-primaria);
            text-align: center;
        }

        .tela-conteudo h2 {
            color: #f8f8f8;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .tela-conteudo p {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .botao-iniciar {
            padding: 12px 24px;
            background-color: var(--cor-primaria);
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .botao-iniciar:active {
            transform: scale(0.98);
        }

        .botao-iniciar:hover {
            background-color: #a0522d;
        }

        #botao-musica {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            position: absolute;
            top: 10px;
            right: 10px;
            outline: none;
        }

        #botao-musica:active {
            transform: scale(0.9);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .input-nome {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border-radius: 6px;
            border: 1px solid var(--cor-primaria);
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Inter', sans-serif;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
        }

        .input-nome::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .link-formulario {
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .link-formulario a {
            color: #f8f8f8;
            text-decoration: underline;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
        }

        .link-formulario a:hover {
            color: #d2b48c;
        }

        .ranking-container {
            width: 100%;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--cor-primaria);
            border-radius: 8px;
            padding: 5px;
        }

        .ranking-titulo {
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--cor-caminho);
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ranking-item:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .ranking-posicao {
            font-weight: bold;
            color: var(--cor-caminho);
        }

        .ranking-nome {
            flex-grow: 1;
            text-align: left;
            padding-left: 10px;
        }

        .ranking-tempo {
            color: var(--cor-caminho);
        }

        .ranking-voce {
            background-color: rgba(139, 69, 19, 0.3) !important;
            font-weight: bold;
        }

        .botao-salvar {
            padding: 8px 16px;
            background-color: var(--cor-primaria);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s;
        }

        .botao-salvar:hover {
            background-color: #a0522d;
        }

        @media (max-height: 500px) and (orientation: landscape) {
            :root {
                --tamanho-bloco: min(10vh, 60px);
            }

            .header {
                margin-bottom: 5px;
            }

            h1 {
                font-size: 1.2rem;
                margin: 5px 0;
            }

            .info-container {
                margin: 2px 0;
            }

            .labirinto-container {
                margin: 5px 0;
            }
        }

        @media (max-width: 350px) {
            .info-nivel, .info-morangos, .info-tempo {
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Labirinto Geom√©trico</h1>
        <button id="botao-musica" style="display: none;">üîá</button>
        <div class="info-container">
            <div class="info-nivel">N√≠vel: <span id="nivel-atual">1</span></div>
            <div class="info-morangos">Morangos: <span id="morangos">0</span>/<span id="morangos-necessarios">3</span></div>
            <div class="info-tempo">Tempo: <span id="tempo-jogo">00:00</span></div>
        </div>
    </div>

    <div class="labirinto-container">
        <div id="labirinto" class="labirinto"></div>
    </div>

    <div id="mensagem" class="mensagem"></div>

    <div id="modal-pergunta" class="modal">
        <div class="modal-content">
            <button class="fechar-modal">&times;</button>
            <div id="texto-pergunta" class="pergunta"></div>
            <div id="opcoes-resposta" class="opcoes-resposta"></div>
        </div>
    </div>

    <div id="tela-inicio" class="tela-inicio">
        <div class="tela-conteudo">
            <h2>Labirinto Geom√©trico</h2>
            <p>Ajude o Tigre a coletar morangos no labirinto!</p>
            <p>Use as teclas ou clique nos blocos adjacentes para se mover.</p>
            <p>Cada morango cont√©m uma pergunta que voc√™ precisa responder.</p>
            <p>Colete pelo menos 3 morangos em cada fase para poder avan√ßar!</p>
            <p>Encontre a sa√≠da nos blocos que n√£o tem morango!</p>
            <p>Boa Sorte!</p>
            <button id="botao-iniciar" class="botao-iniciar">Iniciar Jogo</button>
        </div>
    </div>

    <div id="tela-fim" class="tela-fim" style="display: none;">
        <div class="tela-conteudo">
            <h2>Parab√©ns!</h2>
            <p id="mensagem-final"></p>
            <div id="ranking-container" class="ranking-container">
                <div class="ranking-titulo">Top 10 Melhores Tempos</div>
                <div id="ranking-lista"></div>
            </div>
            <input type="text" id="input-nome" class="input-nome" placeholder="Digite seu nome" maxlength="20">
            <button id="botao-salvar" class="botao-salvar">Salvar</button>
            <div class="link-formulario">
                <p>Por favor, responda nosso formul√°rio:</p>
                <a href="https://docs.google.com/forms/d/e/1FAIpQLScmbEmPKw_0WoNDgfkxyGlhJPfaTYC6sRXc3YxKD90wJGxFlg/viewform?usp=header" 
                   target="_blank">
                    Clique aqui para acessar o formul√°rio
                </a>
            </div>
            <button id="botao-reiniciar" class="botao-iniciar" style="margin-top: 10px;">Jogar Novamente</button>
        </div>
    </div>

    <audio id="musica-fundo" loop>
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
    </audio>
    <audio id="som-passo">
        <source src="https://www.soundjay.com/buttons/sounds/button-09.mp3" type="audio/mpeg">
    </audio>
    <audio id="som-morango">
        <source src="https://www.soundjay.com/buttons/sounds/button-10.mp3" type="audio/mpeg">
    </audio>
    <audio id="som-vitoria">
        <source src="https://www.soundjay.com/buttons/sounds/button-21.mp3" type="audio/mpeg">
    </audio>
    <audio id="som-fase">
        <source src="https://www.soundjay.com/buttons/sounds/button-20.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Elementos do DOM
        const elementos = {
            labirinto: document.getElementById('labirinto'),
            mensagem: document.getElementById('mensagem'),
            nivelAtual: document.getElementById('nivel-atual'),
            morangos: document.getElementById('morangos'),
            morangosNecessarios: document.getElementById('morangos-necessarios'),
            tempoJogo: document.getElementById('tempo-jogo'),
            modalPergunta: document.getElementById('modal-pergunta'),
            textoPergunta: document.getElementById('texto-pergunta'),
            opcoesResposta: document.getElementById('opcoes-resposta'),
            telaInicio: document.getElementById('tela-inicio'),
            telaFim: document.getElementById('tela-fim'),
            botaoIniciar: document.getElementById('botao-iniciar'),
            botaoReiniciar: document.getElementById('botao-reiniciar'),
            botaoSalvar: document.getElementById('botao-salvar'),
            fecharModal: document.querySelector('.fechar-modal'),
            mensagemFinal: document.getElementById('mensagem-final'),
            musicaFundo: document.getElementById('musica-fundo'),
            somPasso: document.getElementById('som-passo'),
            somMorango: document.getElementById('som-morango'),
            somVitoria: document.getElementById('som-vitoria'),
            somFase: document.getElementById('som-fase'),
            botaoMusica: document.getElementById('botao-musica'),
            inputNome: document.getElementById('input-nome'),
            rankingLista: document.getElementById('ranking-lista'),
            rankingContainer: document.getElementById('ranking-container')
        };

        // Configura√ß√µes do jogo
        const config = {
            nivelInicial: 1,
            tamanhoInicial: 7,
            maxNiveis: 3,
            maxTentativasCaminho: 10,
            probabilidadeParede: [0.2, 0.3, 0.4],
            chanceMorango: [0.4, 0.3, 0.2],
            chanceMorangoDificil: [0.1, 0.2, 0.3],
            minMorangosParaPassar: [3, 3, 3],
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            volumeMusica: 0.3,
            volumeEfeitos: 0.5,
            rankingKey: 'labirintoGeometricoRanking',
            maxRankingEntries: 10
        };

        // Banco de perguntas com IDs √∫nicos
        const perguntas = {
            faceis: [
                {
                    id: 1,
                    pergunta: "Quantas faces tem um cubo?",
                    opcoes: ["4", "6", "8", "10"],
                    resposta: 1
                },
                {
                    id: 2,
                    pergunta: "Qual forma tem todas as faces triangulares?",
                    opcoes: ["Cubo", "Pir√¢mide", "Esfera", "Cilindro"],
                    resposta: 1
                },
                {
                    id: 3,
                    pergunta: "Qual objeto tem formato de esfera?",
                    opcoes: ["Dado", "Bola", "Caixa", "Lata"],
                    resposta: 1
                },
                {
                    id: 4,
                    pergunta: "Quantos v√©rtices tem um cubo?",
                    opcoes: ["4", "6", "8", "12"],
                    resposta: 2
                },
                {
                    id: 5,
                    pergunta: "Qual forma lembra uma lata de refrigerante?",
                    opcoes: ["Cubo", "Esfera", "Cilindro", "Pir√¢mide"],
                    resposta: 2
                },
                {
                    id: 6,
                    pergunta: "Quantas arestas tem um cubo?",
                    opcoes: ["6", "8", "12", "14"],
                    resposta: 2
                },
                {
                    id: 7,
                    pergunta: "Qual forma tem uma base circular e um v√©rtice?",
                    opcoes: ["Cilindro", "Cone", "Esfera", "Pir√¢mide"],
                    resposta: 1
                },
                {
                    id: 8,
                    pergunta: "Quantas faces tem uma pir√¢mide de base quadrada?",
                    opcoes: ["4", "5", "6", "8"],
                    resposta: 1
                },
                {
                    id: 9,
                    pergunta: "Qual objeto tem formato de cilindro?",
                    opcoes: ["Bola", "Lata", "Dado", "Chap√©u"],
                    resposta: 1
                },
                {
                    id: 10,
                    pergunta: "Qual forma tem todas as faces quadradas?",
                    opcoes: ["Pir√¢mide", "Cubo", "Esfera", "Cone"],
                    resposta: 1
                }
            ],
            medias: [],
            dificeis: []
        };

        // Estado do jogo
        const estado = {
            nivel: config.nivelInicial,
            tamanhoMapa: config.tamanhoInicial,
            personagemPos: { x: 0, y: 0 },
            saidaPos: { x: 0, y: 0 },
            jogoAtivo: false,
            labirinto: [],
            caminhoValido: [],
            caminhosAlternativos: [],
            destinoClicado: null,
            morangosColetados: 0,
            totalMorangos: 0,
            perguntaAtual: null,
            isPerguntaDificil: false,
            perguntasUsadas: new Set(),
            morangosRestantes: 0,
            musicaLigada: false,
            perguntaAberta: false,
            audioHabilitado: false,
            tempoInicio: 0,
            tempoDecorrido: 0,
            intervaloRelogio: null,
            ranking: []
        };

        // Fun√ß√µes do jogo
        function gerarLabirinto() {
            const tamanho = estado.tamanhoMapa;
            const nivelIndex = estado.nivel - 1;
            estado.labirinto = [];
            estado.morangosRestantes = 0;
            
            const probParede = config.probabilidadeParede[nivelIndex];
            const probMorango = config.chanceMorango[nivelIndex];
            const probMorangoDificil = config.chanceMorangoDificil[nivelIndex];
            
            // Criar labirinto com caminhos principais
            for (let y = 0; y < tamanho; y++) {
                estado.labirinto[y] = [];
                for (let x = 0; x < tamanho; x++) {
                    // Garante caminhos em diagonal e adjacentes
                    if (x === y || x === y+1 || x === y-1 || x+1 === y || x-1 === y) {
                        estado.labirinto[y][x] = ' ';
                    } else if (Math.random() < probParede) {
                        estado.labirinto[y][x] = 'P';
                    } else {
                        estado.labirinto[y][x] = ' ';
                    }
                }
            }
            
            // Posi√ß√£o inicial fixa no canto superior esquerdo
            estado.personagemPos = { x: 0, y: 0 };
            estado.labirinto[0][0] = ' ';
            
            // GERAR SA√çDA EM POSI√á√ÉO ALEAT√ìRIA MAS ACESS√çVEL
            const posicoesPossiveis = [];
            
            // Coletar todas as posi√ß√µes v√°lidas para sa√≠da
            for (let y = 0; y < tamanho; y++) {
                for (let x = 0; x < tamanho; x++) {
                    // N√£o pode ser a posi√ß√£o inicial nem adjacente
                    if ((x !== 0 || y !== 0) && 
                        !(x <= 1 && y <= 1) && 
                        estado.labirinto[y][x] === ' ') {
                        posicoesPossiveis.push({x, y});
                    }
                }
            }
            
            // Escolher posi√ß√£o aleat√≥ria para sa√≠da
            if (posicoesPossiveis.length > 0) {
                const posSaida = posicoesPossiveis[Math.floor(Math.random() * posicoesPossiveis.length)];
                estado.saidaPos = { x: posSaida.x, y: posSaida.y };
                estado.labirinto[posSaida.y][posSaida.x] = 'S';
            } else {
                // Fallback: canto inferior direito se n√£o encontrar posi√ß√£o v√°lida
                estado.saidaPos = { x: tamanho-1, y: tamanho-1 };
                estado.labirinto[tamanho-1][tamanho-1] = 'S';
            }
            
            // Adicionar morangos em posi√ß√µes aleat√≥rias
            for (let y = 0; y < tamanho; y++) {
                for (let x = 0; x < tamanho; x++) {
                    if (estado.labirinto[y][x] === ' ' && !(x === 0 && y === 0)) {
                        if (Math.random() < probMorango) {
                            const isDificil = Math.random() < probMorangoDificil;
                            estado.labirinto[y][x] = isDificil ? 'MD' : 'M';
                            estado.morangosRestantes++;
                        }
                    }
                }
            }
        }

        function encontrarCaminhoValido() {
            const tamanho = estado.tamanhoMapa;
            const visitados = Array(tamanho).fill().map(() => Array(tamanho).fill(false));
            const fila = [{x: 0, y: 0, path: [{x: 0, y: 0}]}];
            visitados[0][0] = true;
            
            const direcoes = [
                {dx: 0, dy: -1}, {dx: 1, dy: 0}, 
                {dx: 0, dy: 1}, {dx: -1, dy: 0}
            ];
            
            while (fila.length > 0) {
                const atual = fila.shift();
                
                if (atual.x === estado.saidaPos.x && atual.y === estado.saidaPos.y) {
                    estado.caminhoValido = atual.path;
                    return true;
                }
                
                for (const dir of direcoes) {
                    const nx = atual.x + dir.dx;
                    const ny = atual.y + dir.dy;
                    
                    if (nx >= 0 && nx < tamanho && ny >= 0 && ny < tamanho && 
                        (estado.labirinto[ny][nx] === ' ' || estado.labirinto[ny][nx] === 'S' || 
                         estado.labirinto[ny][nx] === 'M' || estado.labirinto[ny][nx] === 'MD') && 
                        !visitados[ny][nx]) {
                        visitados[ny][nx] = true;
                        fila.push({
                            x: nx,
                            y: ny,
                            path: [...atual.path, {x: nx, y: ny}]
                        });
                    }
                }
            }
            
            return false;
        }

        function gerarLabirintoValido() {
            let tentativas = 0;
            do {
                gerarLabirinto();
                tentativas++;
            } while (!encontrarCaminhoValido() && tentativas < config.maxTentativasCaminho);
            
            if (tentativas >= config.maxTentativasCaminho) {
                // Criar labirinto padr√£o se n√£o conseguir gerar um v√°lido
                for (let y = 0; y < estado.tamanhoMapa; y++) {
                    for (let x = 0; x < estado.tamanhoMapa; x++) {
                        if (x === y || x === y+1 || x === y-1 || x+1 === y || x-1 === y) {
                            estado.labirinto[y][x] = ' ';
                        }
                    }
                }
                estado.saidaPos = { x: estado.tamanhoMapa-1, y: estado.tamanhoMapa-1 };
                estado.labirinto[estado.tamanhoMapa-1][estado.tamanhoMapa-1] = 'S';
                encontrarCaminhoValido();
            }
            
            // Garantir morangos suficientes
            const minMorangos = config.minMorangosParaPassar[estado.nivel - 1];
            if (estado.morangosRestantes < minMorangos) {
                adicionarMorangosNoCaminho(minMorangos - estado.morangosRestantes);
            }
            
            encontrarCaminhosAlternativos();
            elementos.morangosNecessarios.textContent = minMorangos;
        }

        function adicionarMorangosNoCaminho(quantidade) {
            const caminhoDisponivel = estado.caminhoValido.filter(pos => 
                estado.labirinto[pos.y][pos.x] === ' ' && 
                !(pos.x === estado.personagemPos.x && pos.y === estado.personagemPos.y) &&
                !(pos.x === estado.saidaPos.x && pos.y === estado.saidaPos.y));
            
            const posicoesAleatorias = caminhoDisponivel
                .sort(() => 0.5 - Math.random())
                .slice(0, quantidade);
            
            posicoesAleatorias.forEach(pos => {
                estado.labirinto[pos.y][pos.x] = 'M';
                estado.morangosRestantes++;
            });
        }

        function encontrarCaminhosAlternativos() {
            const tamanho = estado.tamanhoMapa;
            const visitados = Array(tamanho).fill().map(() => Array(tamanho).fill(false));
            estado.caminhosAlternativos = [];
            
            estado.caminhoValido.forEach(pos => {
                visitados[pos.y][pos.x] = true;
            });
            
            for (let y = 0; y < tamanho; y++) {
                for (let x = 0; x < tamanho; x++) {
                    if ((estado.labirinto[y][x] === ' ' || estado.labirinto[y][x] === 'M' || estado.labirinto[y][x] === 'MD') && !visitados[y][x]) {
                        const caminho = [];
                        preencherCaminho(x, y, visitados, caminho);
                        if (caminho.length > 0) {
                            estado.caminhosAlternativos.push(caminho);
                        }
                    }
                }
            }
        }

        function preencherCaminho(x, y, visitados, caminho) {
            const tamanho = estado.tamanhoMapa;
            if (x < 0 || x >= tamanho || y < 0 || y >= tamanho || 
                visitados[y][x] || estado.labirinto[y][x] === 'P') {
                return;
            }
            
            visitados[y][x] = true;
            caminho.push({x, y});
            
            preencherCaminho(x+1, y, visitados, caminho);
            preencherCaminho(x-1, y, visitados, caminho);
            preencherCaminho(x, y+1, visitados, caminho);
            preencherCaminho(x, y-1, visitados, caminho);
        }

        function atualizarUI() {
            elementos.labirinto.innerHTML = '';
            elementos.labirinto.style.gridTemplateColumns = `repeat(${estado.tamanhoMapa}, 1fr)`;
            
            for (let y = 0; y < estado.tamanhoMapa; y++) {
                for (let x = 0; x < estado.tamanhoMapa; x++) {
                    const bloco = document.createElement('div');
                    bloco.classList.add('bloco');
                    
                    const noCaminhoPrincipal = estado.caminhoValido.some(pos => pos.x === x && pos.y === y);
                    const noCaminhoAlternativo = estado.caminhosAlternativos.some(caminho => 
                        caminho.some(pos => pos.x === x && pos.y === y));
                    
                    if (estado.labirinto[y][x] === 'P') {
                        bloco.classList.add('parede');
                    } else if (estado.labirinto[y][x] === 'S') {
                        bloco.classList.add('saida');
                    } else if (estado.labirinto[y][x] === 'M') {
                        bloco.classList.add('morango');
                    } else if (estado.labirinto[y][x] === 'MD') {
                        bloco.classList.add('morango-dificil');
                        bloco.setAttribute('data-dificil', 'true');
                    } else if (noCaminhoPrincipal || noCaminhoAlternativo) {
                        bloco.classList.add('caminho');
                    } else {
                        bloco.classList.add('parede');
                    }
                    
                    // Adicionar personagem na posi√ß√£o atual
                    if (x === estado.personagemPos.x && y === estado.personagemPos.y) {
                        const personagem = document.createElement('div');
                        personagem.classList.add('personagem');
                        bloco.appendChild(personagem);
                    }
                    
                    if ((noCaminhoPrincipal || noCaminhoAlternativo || 
                         estado.labirinto[y][x] === 'M' || estado.labirinto[y][x] === 'MD' || 
                         estado.labirinto[y][x] === 'S') && 
                        !(x === estado.personagemPos.x && y === estado.personagemPos.y)) {
                        bloco.addEventListener('click', () => clicarNoBloco(x, y));
                    }
                    
                    elementos.labirinto.appendChild(bloco);
                }
            }
            
            elementos.nivelAtual.textContent = estado.nivel;
            elementos.morangos.textContent = estado.morangosColetados;
        }

        function mostrarMensagem(texto, tipo) {
            elementos.mensagem.textContent = texto;
            elementos.mensagem.className = `mensagem ${tipo}`;
            setTimeout(() => {
                elementos.mensagem.textContent = '';
                elementos.mensagem.className = 'mensagem';
            }, 2000);
        }

        function clicarNoBloco(x, y) {
            if (!estado.jogoAtivo || estado.perguntaAberta) return;
            
            const dx = Math.abs(estado.personagemPos.x - x);
            const dy = Math.abs(estado.personagemPos.y - y);
            
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                estado.destinoClicado = {x, y};
                
                if (estado.labirinto[y][x] === 'M' || estado.labirinto[y][x] === 'MD') {
                    estado.isPerguntaDificil = estado.labirinto[y][x] === 'MD';
                    mostrarPergunta();
                } else if (estado.labirinto[y][x] === 'S') {
                    const minMorangos = config.minMorangosParaPassar[estado.nivel - 1];
                    if (estado.morangosColetados >= minMorangos) {
                        estado.isPerguntaDificil = false;
                        mostrarPergunta();
                    } else {
                        const faltam = minMorangos - estado.morangosColetados;
                        mostrarMensagem(`Colete mais ${faltam} morango(s) para passar!`, 'erro');
                    }
                } else {
                    moverPersonagemParaDestino();
                }
            } else {
                mostrarMensagem("Mova apenas para blocos adjacentes!", 'erro');
            }
        }

        function obterPerguntaAleatoria(categoria) {
            // Se j√° usamos todas as perguntas, limpe o conjunto e comece de novo
            if (estado.perguntasUsadas.size >= perguntas[categoria].length) {
                estado.perguntasUsadas.clear();
            }

            // Filtre as perguntas que ainda n√£o foram usadas
            const perguntasDisponiveis = perguntas[categoria].filter(p => 
                !estado.perguntasUsadas.has(p.id));

            // Se n√£o houver perguntas dispon√≠veis (teoricamente n√£o deveria acontecer devido √† verifica√ß√£o acima)
            if (perguntasDisponiveis.length === 0) {
                estado.perguntasUsadas.clear();
                return perguntas[categoria][Math.floor(Math.random() * perguntas[categoria].length)];
            }
            
            // Escolha uma pergunta aleat√≥ria entre as dispon√≠veis
            const perguntaAleatoria = perguntasDisponiveis[Math.floor(Math.random() * perguntasDisponiveis.length)];
            
            // Marque a pergunta como usada
            estado.perguntasUsadas.add(perguntaAleatoria.id);
            
            return perguntaAleatoria;
        }

        function mostrarPergunta() {
            estado.perguntaAberta = true;
            let perguntaAleatoria = obterPerguntaAleatoria('faceis');
            estado.perguntaAtual = perguntaAleatoria;
            
            elementos.textoPergunta.textContent = perguntaAleatoria.pergunta;
            elementos.opcoesResposta.innerHTML = '';
                
            perguntaAleatoria.opcoes.forEach((opcao, index) => {
                const botao = document.createElement('button');
                botao.classList.add('opcao');
                botao.textContent = opcao;
                botao.addEventListener('click', () => verificarResposta(index === perguntaAleatoria.resposta));
                elementos.opcoesResposta.appendChild(botao);
            });
            
            elementos.modalPergunta.style.display = 'flex';
        }

        function verificarResposta(correta) {
            estado.perguntaAberta = false;
            elementos.modalPergunta.style.display = 'none';
            
            const destino = estado.destinoClicado;
            const bloco = estado.labirinto[destino.y][destino.x];
            
            if (correta) {
                if (bloco === 'M' || bloco === 'MD') {
                    estado.morangosColetados++;
                    estado.totalMorangos++;
                    estado.morangosRestantes--;
                    tocarSom(elementos.somMorango);
                }
                
                if (bloco === 'M' || bloco === 'MD') {
                    estado.labirinto[destino.y][destino.x] = ' ';
                }
                
                mostrarMensagem("Correto!", 'acerto');
                moverPersonagemParaDestino();
            } else {
                mostrarMensagem("Incorreto! Tente novamente.", 'erro');
            }
            
            atualizarUI();
        }

        function moverPersonagemParaDestino() {
            const destino = estado.destinoClicado;
            estado.personagemPos = {...destino};
            tocarSom(elementos.somPasso);
            
            if (estado.labirinto[destino.y][destino.x] === 'S') {
                const minMorangos = config.minMorangosParaPassar[estado.nivel - 1];
                if (estado.morangosColetados >= minMorangos) {
                    estado.jogoAtivo = false;
                    
                    if (estado.nivel >= config.maxNiveis) {
                        tocarSom(elementos.somVitoria);
                        finalizarJogo(`Parab√©ns! Voc√™ completou todas as ${config.maxNiveis} fases!`);
                    } else {
                        tocarSom(elementos.somFase);
                        setTimeout(() => {
                            estado.nivel++;
                            estado.morangosColetados = 0;
                            estado.jogoAtivo = true;
                            gerarLabirintoValido();
                            atualizarUI();
                            mostrarMensagem(`Fase ${estado.nivel}: Colete ${config.minMorangosParaPassar[estado.nivel - 1]} morangos para avan√ßar!`, 'acerto');
                        }, 1000);
                    }
                }
            } else {
                atualizarUI();
            }
        }

        function tocarSom(elementoAudio) {
            try {
                if (!estado.audioHabilitado) return;
                
                elementoAudio.volume = config.volumeEfeitos;
                elementoAudio.currentTime = 0;
                const promise = elementoAudio.play();
                
                if (promise !== undefined) {
                    promise.catch(e => {
                        console.log("Erro ao reproduzir som:", e);
                    });
                }
            } catch (e) {
                console.log("Erro ao reproduzir som:", e);
            }
        }

        function toggleMusica() {
            if (!estado.audioHabilitado) {
                habilitarAudio();
                return;
            }
            
            if (estado.musicaLigada) {
                elementos.musicaFundo.pause();
                estado.musicaLigada = false;
                elementos.botaoMusica.textContent = 'üîá';
            } else {
                elementos.musicaFundo.play().catch(e => {
                    console.log("Erro ao reproduzir m√∫sica:", e);
                });
                estado.musicaLigada = true;
                elementos.botaoMusica.textContent = 'üîä';
            }
        }

        function habilitarAudio() {
            if (!estado.audioHabilitado) {
                estado.audioHabilitado = true;
                elementos.botaoMusica.style.display = 'block';
                
                // Configurar volumes
                elementos.musicaFundo.volume = config.volumeMusica;
                elementos.somPasso.volume = config.volumeEfeitos;
                elementos.somMorango.volume = config.volumeEfeitos;
                elementos.somVitoria.volume = config.volumeEfeitos;
                elementos.somFase.volume = config.volumeEfeitos;
                
                // Tentar iniciar a m√∫sica imediatamente
                const promise = elementos.musicaFundo.play();
                
                if (promise !== undefined) {
                    promise.catch(error => {
                        console.log("Reprodu√ß√£o autom√°tica bloqueada:", error);
                        // Mostrar bot√£o para permitir que o usu√°rio inicie a m√∫sica manualmente
                        elementos.botaoMusica.textContent = 'üîá';
                        estado.musicaLigada = false;
                    }).then(() => {
                        estado.musicaLigada = true;
                        elementos.botaoMusica.textContent = 'üîä';
                    });
                }
            }
        }

        function formatarTempo(segundos) {
            const mins = Math.floor(segundos / 60);
            const secs = Math.floor(segundos % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function atualizarRelogio() {
            const tempoAtual = Math.floor((Date.now() - estado.tempoInicio) / 1000) + estado.tempoDecorrido;
            elementos.tempoJogo.textContent = formatarTempo(tempoAtual);
        }

        function iniciarRelogio() {
            estado.tempoInicio = Date.now();
            estado.tempoDecorrido = 0;
            clearInterval(estado.intervaloRelogio);
            estado.intervaloRelogio = setInterval(atualizarRelogio, 1000);
        }

        function pausarRelogio() {
            if (estado.tempoInicio) {
                estado.tempoDecorrido += Math.floor((Date.now() - estado.tempoInicio) / 1000);
                estado.tempoInicio = 0;
            }
            clearInterval(estado.intervaloRelogio);
        }

        function obterTempoAtual() {
            if (estado.tempoInicio) {
                return estado.tempoDecorrido + Math.floor((Date.now() - estado.tempoInicio) / 1000);
            }
            return estado.tempoDecorrido;
        }

        function carregarRanking() {
            const rankingSalvo = localStorage.getItem(config.rankingKey);
            if (rankingSalvo) {
                estado.ranking = JSON.parse(rankingSalvo);
            } else {
                estado.ranking = [];
            }
        }

        function salvarRanking() {
            localStorage.setItem(config.rankingKey, JSON.stringify(estado.ranking));
        }

        function adicionarAoRanking(nome, tempo) {
            // Verificar se o nome j√° existe no ranking
            const entradaExistenteIndex = estado.ranking.findIndex(entry => entry.nome === nome);
            
            if (entradaExistenteIndex !== -1) {
                // Se o novo tempo for melhor, atualiza
                if (tempo < estado.ranking[entradaExistenteIndex].tempo) {
                    estado.ranking[entradaExistenteIndex].tempo = tempo;
                }
            } else {
                // Adiciona nova entrada
                estado.ranking.push({ nome, tempo });
            }
            
            // Ordenar por tempo crescente
            estado.ranking.sort((a, b) => a.tempo - b.tempo);
            
            // Manter apenas os top 10
            if (estado.ranking.length > config.maxRankingEntries) {
                estado.ranking = estado.ranking.slice(0, config.maxRankingEntries);
            }
            
            salvarRanking();
        }

        function exibirRanking(nomeAtual = '') {
            elementos.rankingLista.innerHTML = '';
            
            if (estado.ranking.length === 0) {
                const item = document.createElement('div');
                item.textContent = 'Nenhum recorde ainda!';
                elementos.rankingLista.appendChild(item);
                return;
            }
            
            estado.ranking.forEach((entry, index) => {
                const item = document.createElement('div');
                item.className = `ranking-item ${entry.nome === nomeAtual ? 'ranking-voce' : ''}`;
                
                const posicao = document.createElement('span');
                posicao.className = 'ranking-posicao';
                posicao.textContent = `${index + 1}¬∫`;
                
                const nome = document.createElement('span');
                nome.className = 'ranking-nome';
                nome.textContent = entry.nome;
                
                const tempo = document.createElement('span');
                tempo.className = 'ranking-tempo';
                tempo.textContent = formatarTempo(entry.tempo);
                
                item.appendChild(posicao);
                item.appendChild(nome);
                item.appendChild(tempo);
                
                elementos.rankingLista.appendChild(item);
            });
        }

        function finalizarJogo(mensagem) {
            pausarRelogio();
            const tempoTotal = obterTempoAtual();
            
            elementos.mensagemFinal.textContent = `${mensagem} Tempo total: ${formatarTempo(tempoTotal)} | Morangos: ${estado.totalMorangos}`;
            elementos.telaFim.style.display = 'flex';
            
            // Exibir ranking
            carregarRanking();
            exibirRanking();
            
            // Configurar input de nome
            elementos.inputNome.value = '';
            elementos.inputNome.focus();
        }

        function salvarNome() {
            const nome = elementos.inputNome.value.trim();
            if (nome) {
                const tempoTotal = obterTempoAtual();
                adicionarAoRanking(nome, tempoTotal);
                exibirRanking(nome);
                elementos.inputNome.style.display = 'none';
                elementos.botaoSalvar.style.display = 'none';
            }
        }

        function moverPersonagem(dx, dy) {
            if (!estado.jogoAtivo || estado.perguntaAberta) return;
            
            const novoX = estado.personagemPos.x + dx;
            const novoY = estado.personagemPos.y + dy;
            
            const noCaminhoPrincipal = estado.caminhoValido.some(pos => pos.x === novoX && pos.y === novoY);
            const noCaminhoAlternativo = estado.caminhosAlternativos.some(caminho => 
                caminho.some(pos => pos.x === novoX && pos.y === novoY));
            const naSaida = (novoX === estado.saidaPos.x && novoY === estado.saidaPos.y);
            const noMorango = estado.labirinto[novoY][novoX] === 'M' || estado.labirinto[novoY][novoX] === 'MD';
            
            if (novoX >= 0 && novoX < estado.tamanhoMapa && 
                novoY >= 0 && novoY < estado.tamanhoMapa && 
                (noCaminhoPrincipal || noCaminhoAlternativo || naSaida || noMorango)) {
                
                if (noMorango) {
                    estado.destinoClicado = {x: novoX, y: novoY};
                    estado.isPerguntaDificil = estado.labirinto[novoY][novoX] === 'MD';
                    mostrarPergunta();
                    return;
                }
                
                if (naSaida) {
                    const minMorangos = config.minMorangosParaPassar[estado.nivel - 1];
                    if (estado.morangosColetados >= minMorangos) {
                        estado.destinoClicado = {x: novoX, y: novoY};
                        estado.isPerguntaDificil = false;
                        mostrarPergunta();
                    } else {
                        const faltam = minMorangos - estado.morangosColetados;
                        mostrarMensagem(`Colete mais ${faltam} morango(s) para passar!`, 'erro');
                    }
                    return;
                }
                
                estado.personagemPos.x = novoX;
                estado.personagemPos.y = novoY;
                tocarSom(elementos.somPasso);
                atualizarUI();
            }
        }

        function reiniciarJogo() {
            estado.nivel = config.nivelInicial;
            estado.morangosColetados = 0;
            estado.totalMorangos = 0;
            estado.perguntasUsadas.clear();
            estado.perguntaAberta = false;
            
            elementos.telaFim.style.display = 'none';
            elementos.inputNome.style.display = 'block';
            elementos.botaoSalvar.style.display = 'block';
            
            iniciarJogo();
        }

        function iniciarJogo() {
            estado.jogoAtivo = true;
            estado.nivel = 1;
            estado.morangosColetados = 0;
            estado.totalMorangos = 0;
            estado.perguntasUsadas.clear();
            estado.perguntaAberta = false;
            gerarLabirintoValido();
            atualizarUI();
            
            elementos.telaInicio.style.display = 'none';
            
            // Iniciar rel√≥gio
            iniciarRelogio();
            
            // Habilitar o √°udio automaticamente quando o jogo come√ßar
            habilitarAudio();
            
            mostrarMensagem(`Fase 1: Colete ${config.minMorangosParaPassar[0]} morangos para avan√ßar!`, 'acerto');
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Configurar os elementos de √°udio
            elementos.musicaFundo.volume = config.volumeMusica;
            elementos.somPasso.volume = config.volumeEfeitos;
            elementos.somMorango.volume = config.volumeEfeitos;
            elementos.somVitoria.volume = config.volumeEfeitos;
            elementos.somFase.volume = config.volumeEfeitos;
            
            // Configurar loop para a m√∫sica de fundo
            elementos.musicaFundo.loop = true;
            
            // Tentar carregar a m√∫sica antecipadamente
            elementos.musicaFundo.load();

            // Tentar iniciar a m√∫sica automaticamente (com tratamento de erro)
            document.body.addEventListener('click', function habilitarAudioAutomatico() {
                habilitarAudio();
                document.body.removeEventListener('click', habilitarAudioAutomatico);
            }, { once: true });

            elementos.botaoIniciar.addEventListener('click', iniciarJogo);
            
            elementos.botaoReiniciar.addEventListener('click', reiniciarJogo);
            elementos.botaoSalvar.addEventListener('click', salvarNome);
            elementos.fecharModal.addEventListener('click', () => {
                estado.perguntaAberta = false;
                elementos.modalPergunta.style.display = 'none';
            });
            
            elementos.botaoMusica.addEventListener('click', toggleMusica);
            
            window.addEventListener('keydown', (e) => {
                // Impedir navega√ß√£o entre op√ß√µes com as teclas de seta quando o modal est√° aberto
                if (estado.perguntaAberta && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    return;
                }
                
                // Verificar se uma pergunta est√° aberta antes de mover o personagem
                if (!estado.perguntaAberta) {
                    switch(e.key) {
                        case 'ArrowUp': moverPersonagem(0, -1); break;
                        case 'ArrowDown': moverPersonagem(0, 1); break;
                        case 'ArrowLeft': moverPersonagem(-1, 0); break;
                        case 'ArrowRight': moverPersonagem(1, 0); break;
                        case 'm': toggleMusica(); break;
                    }
                }
            });

            elementos.telaInicio.style.display = 'flex';
        });
    </script>
</body>
</html>